package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

func TestEscapeEnvValue(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "simple value",
			input:    "simple123",
			expected: "simple123",
		},
		{
			name:     "empty value",
			input:    "",
			expected: "",
		},
		{
			name:     "value with space",
			input:    "hello world",
			expected: `"hello world"`,
		},
		{
			name:     "value with double quote",
			input:    `hello"world`,
			expected: `"hello\"world"`,
		},
		{
			name:     "value with single quote",
			input:    "hello'world",
			expected: `"hello'world"`,
		},
		{
			name:     "value with backslash",
			input:    `hello\world`,
			expected: `"hello\\world"`,
		},
		{
			name:     "value with newline",
			input:    "hello\nworld",
			expected: `"hello\nworld"`,
		},
		{
			name:     "value with carriage return",
			input:    "hello\rworld",
			expected: `"hello\rworld"`,
		},
		{
			name:     "value with tab",
			input:    "hello\tworld",
			expected: `"hello\tworld"`,
		},
		{
			name:     "value with hash",
			input:    "hello#world",
			expected: `"hello#world"`,
		},
		{
			name:     "value with dollar",
			input:    "hello$world",
			expected: `"hello\$world"`,
		},
		{
			name:     "value with equals",
			input:    "hello=world",
			expected: `"hello=world"`,
		},
		{
			name:     "complex value",
			input:    `pass word "with" $pecial\chars`,
			expected: `"pass word \"with\" \$pecial\\chars"`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := escapeEnvValue(tt.input)
			if result != tt.expected {
				t.Errorf("escapeEnvValue(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestGenerateEnvOutput(t *testing.T) {
	secrets := []exportSecretData{
		{
			key:     "api/key",
			envName: "API_KEY",
			value:   []byte("secret123"),
		},
		{
			key:     "db/password",
			envName: "DB_PASSWORD",
			value:   []byte("p@ssw0rd"),
		},
	}

	output := generateEnvOutput(secrets)

	// Check header
	if !strings.Contains(output, "# Generated by secretctl") {
		t.Error("output should contain generation header")
	}
	if !strings.Contains(output, "# WARNING: DO NOT COMMIT THIS FILE TO VERSION CONTROL") {
		t.Error("output should contain warning header")
	}

	// Check key-value pairs
	if !strings.Contains(output, "API_KEY=secret123") {
		t.Error("output should contain API_KEY=secret123")
	}
	if !strings.Contains(output, "DB_PASSWORD=p@ssw0rd") {
		t.Error("output should contain DB_PASSWORD=p@ssw0rd")
	}
}

func TestGenerateEnvOutputWithSpecialChars(t *testing.T) {
	secrets := []exportSecretData{
		{
			key:     "special",
			envName: "SPECIAL",
			value:   []byte("value with spaces"),
		},
	}

	output := generateEnvOutput(secrets)

	if !strings.Contains(output, `SPECIAL="value with spaces"`) {
		t.Errorf("output should quote value with spaces, got: %s", output)
	}
}

func TestGenerateJSONOutput(t *testing.T) {
	secrets := []exportSecretData{
		{
			key:     "api/key",
			envName: "API_KEY",
			value:   []byte("secret123"),
		},
		{
			key:     "db/password",
			envName: "DB_PASSWORD",
			value:   []byte("p@ssw0rd"),
		},
	}

	output, err := generateJSONOutput(secrets, false)
	if err != nil {
		t.Fatalf("generateJSONOutput failed: %v", err)
	}

	// Check JSON structure
	if !strings.Contains(output, `"API_KEY": "secret123"`) {
		t.Errorf("output should contain API_KEY, got: %s", output)
	}
	if !strings.Contains(output, `"DB_PASSWORD": "p@ssw0rd"`) {
		t.Errorf("output should contain DB_PASSWORD, got: %s", output)
	}
}

func TestGenerateJSONOutputWithMetadata(t *testing.T) {
	now := time.Now()
	secrets := []exportSecretData{
		{
			key:       "api/key",
			envName:   "API_KEY",
			value:     []byte("secret123"),
			createdAt: now,
			updatedAt: now,
			expiresAt: nil,
		},
	}

	output, err := generateJSONOutput(secrets, true)
	if err != nil {
		t.Fatalf("generateJSONOutput with metadata failed: %v", err)
	}

	// Check metadata fields
	if !strings.Contains(output, `"value": "secret123"`) {
		t.Errorf("output should contain value field, got: %s", output)
	}
	if !strings.Contains(output, `"created_at":`) {
		t.Errorf("output should contain created_at field, got: %s", output)
	}
	if !strings.Contains(output, `"updated_at":`) {
		t.Errorf("output should contain updated_at field, got: %s", output)
	}
}

func TestGenerateJSONOutputWithExpiration(t *testing.T) {
	now := time.Now()
	expiry := now.Add(24 * time.Hour)
	secrets := []exportSecretData{
		{
			key:       "api/key",
			envName:   "API_KEY",
			value:     []byte("secret123"),
			createdAt: now,
			updatedAt: now,
			expiresAt: &expiry,
		},
	}

	output, err := generateJSONOutput(secrets, true)
	if err != nil {
		t.Fatalf("generateJSONOutput with expiration failed: %v", err)
	}

	if !strings.Contains(output, `"expires_at":`) {
		t.Errorf("output should contain expires_at field, got: %s", output)
	}
}

func TestWriteSecureFile(t *testing.T) {
	// Create temp directory
	tmpDir := t.TempDir()

	t.Run("write to simple path", func(t *testing.T) {
		path := filepath.Join(tmpDir, "test.env")
		content := "TEST=value"

		err := writeSecureFile(path, content, false)
		if err != nil {
			t.Fatalf("writeSecureFile failed: %v", err)
		}

		// Verify file exists
		info, err := os.Stat(path)
		if err != nil {
			t.Fatalf("failed to stat file: %v", err)
		}

		// Verify permissions (0600)
		if info.Mode().Perm() != 0600 {
			t.Errorf("file permissions = %o, want 0600", info.Mode().Perm())
		}

		// Verify content
		data, err := os.ReadFile(path)
		if err != nil {
			t.Fatalf("failed to read file: %v", err)
		}
		if string(data) != content {
			t.Errorf("file content = %q, want %q", string(data), content)
		}
	})

	t.Run("write to nested path", func(t *testing.T) {
		path := filepath.Join(tmpDir, "subdir", "nested", "test.json")
		content := `{"key": "value"}`

		err := writeSecureFile(path, content, false)
		if err != nil {
			t.Fatalf("writeSecureFile to nested path failed: %v", err)
		}

		// Verify file exists
		_, err = os.Stat(path)
		if err != nil {
			t.Fatalf("nested file not created: %v", err)
		}
	})

	t.Run("write to current directory", func(t *testing.T) {
		// Change to temp dir
		oldWd, _ := os.Getwd()
		defer func() { _ = os.Chdir(oldWd) }()
		_ = os.Chdir(tmpDir)

		path := "current.env"
		content := "CURRENT=true"

		err := writeSecureFile(path, content, false)
		if err != nil {
			t.Fatalf("writeSecureFile to current dir failed: %v", err)
		}

		// Verify file exists
		_, err = os.Stat(filepath.Join(tmpDir, path))
		if err != nil {
			t.Fatalf("file in current dir not created: %v", err)
		}
	})
}

// Security tests

func TestWriteSecureFileOverwriteProtection(t *testing.T) {
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "existing.env")

	// Create existing file
	if err := os.WriteFile(path, []byte("old content"), 0600); err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}

	t.Run("refuse overwrite without force", func(t *testing.T) {
		err := writeSecureFile(path, "new content", false)
		if err == nil {
			t.Error("expected error when overwriting without force")
		}
		if !strings.Contains(err.Error(), "file already exists") {
			t.Errorf("expected 'file already exists' error, got: %v", err)
		}

		// Verify original content unchanged
		data, _ := os.ReadFile(path)
		if string(data) != "old content" {
			t.Error("file content was changed without force flag")
		}
	})

	t.Run("allow overwrite with force", func(t *testing.T) {
		err := writeSecureFile(path, "new content", true)
		if err != nil {
			t.Fatalf("writeSecureFile with force failed: %v", err)
		}

		// Verify new content
		data, _ := os.ReadFile(path)
		if string(data) != "new content" {
			t.Errorf("file content = %q, want 'new content'", string(data))
		}
	})
}

func TestWriteSecureFileSymlinkProtection(t *testing.T) {
	tmpDir := t.TempDir()

	// Create target file
	targetPath := filepath.Join(tmpDir, "target.txt")
	if err := os.WriteFile(targetPath, []byte("target content"), 0600); err != nil {
		t.Fatalf("failed to create target file: %v", err)
	}

	// Create symlink
	symlinkPath := filepath.Join(tmpDir, "symlink.env")
	if err := os.Symlink(targetPath, symlinkPath); err != nil {
		t.Skipf("symlink creation not supported: %v", err)
	}

	t.Run("refuse write to symlink", func(t *testing.T) {
		err := writeSecureFile(symlinkPath, "malicious content", false)
		if err == nil {
			t.Error("expected error when writing to symlink")
		}
		if !strings.Contains(err.Error(), "symlink") {
			t.Errorf("expected symlink error, got: %v", err)
		}

		// Verify target file unchanged
		data, _ := os.ReadFile(targetPath)
		if string(data) != "target content" {
			t.Error("symlink target was modified")
		}
	})

	t.Run("refuse write to symlink even with force", func(t *testing.T) {
		err := writeSecureFile(symlinkPath, "malicious content", true)
		if err == nil {
			t.Error("expected error when writing to symlink even with force")
		}
	})
}

func TestWriteSecureFileSystemDirectoryProtection(t *testing.T) {
	// Test that we refuse to write to sensitive system directories
	sensitivePaths := []string{
		"/etc/passwd",
		"/usr/local/test.env",
		"/var/log/test.env",
		"/var/run/test.env",
	}

	for _, path := range sensitivePaths {
		t.Run("refuse_"+strings.ReplaceAll(path, "/", "_"), func(t *testing.T) {
			err := writeSecureFile(path, "content", false)
			if err == nil {
				t.Errorf("expected error for sensitive path: %s", path)
			}
			if !strings.Contains(err.Error(), "security") && !strings.Contains(err.Error(), "permission") {
				// Either security check or permission denied is acceptable
				t.Logf("got error (expected): %v", err)
			}
		})
	}
}

func TestWriteSecureFileAllowsUserDirectories(t *testing.T) {
	// Ensure we don't block legitimate directories like /var/folders (macOS temp)
	// and user home directories
	tmpDir := t.TempDir() // Uses system temp which may be under /var/folders on macOS

	path := filepath.Join(tmpDir, "allowed.env")
	err := writeSecureFile(path, "ALLOWED=true", false)
	if err != nil {
		t.Errorf("should allow writing to temp directory: %v", err)
	}
}

func TestWriteSecureFileDirectoryPermissions(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a subdirectory with weak permissions
	weakDir := filepath.Join(tmpDir, "weak")
	if err := os.MkdirAll(weakDir, 0755); err != nil {
		t.Fatalf("failed to create weak dir: %v", err)
	}

	path := filepath.Join(weakDir, "secret.env")
	err := writeSecureFile(path, "SECRET=value", false)
	if err != nil {
		t.Fatalf("writeSecureFile failed: %v", err)
	}

	// Verify directory permissions were tightened
	info, err := os.Stat(weakDir)
	if err != nil {
		t.Fatalf("failed to stat directory: %v", err)
	}
	if info.Mode().Perm() != 0700 {
		t.Errorf("directory permissions = %o, want 0700", info.Mode().Perm())
	}
}

func TestExportSecretDataStruct(t *testing.T) {
	now := time.Now()
	expiry := now.Add(time.Hour)

	data := exportSecretData{
		key:       "test/key",
		envName:   "TEST_KEY",
		value:     []byte("secret"),
		createdAt: now,
		updatedAt: now,
		expiresAt: &expiry,
	}

	if data.key != "test/key" {
		t.Errorf("key = %s, want test/key", data.key)
	}
	if data.envName != "TEST_KEY" {
		t.Errorf("envName = %s, want TEST_KEY", data.envName)
	}
	if string(data.value) != "secret" {
		t.Errorf("value = %s, want secret", string(data.value))
	}
	if data.expiresAt == nil {
		t.Error("expiresAt should not be nil")
	}
}

func TestExportSecretMetadataStruct(t *testing.T) {
	created := "2025-01-01T00:00:00Z"
	updated := "2025-01-02T00:00:00Z"

	meta := exportSecretMetadata{
		Value:     "secret",
		CreatedAt: &created,
		UpdatedAt: &updated,
		ExpiresAt: nil,
	}

	if meta.Value != "secret" {
		t.Errorf("Value = %s, want secret", meta.Value)
	}
	if *meta.CreatedAt != created {
		t.Errorf("CreatedAt = %s, want %s", *meta.CreatedAt, created)
	}
	if meta.ExpiresAt != nil {
		t.Error("ExpiresAt should be nil")
	}
}
