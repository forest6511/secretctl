package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

func TestEscapeEnvValue(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "simple value",
			input:    "simple123",
			expected: "simple123",
		},
		{
			name:     "empty value",
			input:    "",
			expected: "",
		},
		{
			name:     "value with space",
			input:    "hello world",
			expected: `"hello world"`,
		},
		{
			name:     "value with double quote",
			input:    `hello"world`,
			expected: `"hello\"world"`,
		},
		{
			name:     "value with single quote",
			input:    "hello'world",
			expected: `"hello'world"`,
		},
		{
			name:     "value with backslash",
			input:    `hello\world`,
			expected: `"hello\\world"`,
		},
		{
			name:     "value with newline",
			input:    "hello\nworld",
			expected: `"hello\nworld"`,
		},
		{
			name:     "value with carriage return",
			input:    "hello\rworld",
			expected: `"hello\rworld"`,
		},
		{
			name:     "value with tab",
			input:    "hello\tworld",
			expected: `"hello\tworld"`,
		},
		{
			name:     "value with hash",
			input:    "hello#world",
			expected: `"hello#world"`,
		},
		{
			name:     "value with dollar",
			input:    "hello$world",
			expected: `"hello\$world"`,
		},
		{
			name:     "complex value",
			input:    `pass word "with" $pecial\chars`,
			expected: `"pass word \"with\" \$pecial\\chars"`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := escapeEnvValue(tt.input)
			if result != tt.expected {
				t.Errorf("escapeEnvValue(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestGenerateEnvOutput(t *testing.T) {
	secrets := []exportSecretData{
		{
			key:     "api/key",
			envName: "API_KEY",
			value:   []byte("secret123"),
		},
		{
			key:     "db/password",
			envName: "DB_PASSWORD",
			value:   []byte("p@ssw0rd"),
		},
	}

	output := generateEnvOutput(secrets)

	// Check header
	if !strings.Contains(output, "# Generated by secretctl") {
		t.Error("output should contain generation header")
	}
	if !strings.Contains(output, "# WARNING: DO NOT COMMIT THIS FILE TO VERSION CONTROL") {
		t.Error("output should contain warning header")
	}

	// Check key-value pairs
	if !strings.Contains(output, "API_KEY=secret123") {
		t.Error("output should contain API_KEY=secret123")
	}
	if !strings.Contains(output, "DB_PASSWORD=p@ssw0rd") {
		t.Error("output should contain DB_PASSWORD=p@ssw0rd")
	}
}

func TestGenerateEnvOutputWithSpecialChars(t *testing.T) {
	secrets := []exportSecretData{
		{
			key:     "special",
			envName: "SPECIAL",
			value:   []byte("value with spaces"),
		},
	}

	output := generateEnvOutput(secrets)

	if !strings.Contains(output, `SPECIAL="value with spaces"`) {
		t.Errorf("output should quote value with spaces, got: %s", output)
	}
}

func TestGenerateJSONOutput(t *testing.T) {
	secrets := []exportSecretData{
		{
			key:     "api/key",
			envName: "API_KEY",
			value:   []byte("secret123"),
		},
		{
			key:     "db/password",
			envName: "DB_PASSWORD",
			value:   []byte("p@ssw0rd"),
		},
	}

	output, err := generateJSONOutput(secrets, false)
	if err != nil {
		t.Fatalf("generateJSONOutput failed: %v", err)
	}

	// Check JSON structure
	if !strings.Contains(output, `"API_KEY": "secret123"`) {
		t.Errorf("output should contain API_KEY, got: %s", output)
	}
	if !strings.Contains(output, `"DB_PASSWORD": "p@ssw0rd"`) {
		t.Errorf("output should contain DB_PASSWORD, got: %s", output)
	}
}

func TestGenerateJSONOutputWithMetadata(t *testing.T) {
	now := time.Now()
	secrets := []exportSecretData{
		{
			key:       "api/key",
			envName:   "API_KEY",
			value:     []byte("secret123"),
			createdAt: now,
			updatedAt: now,
			expiresAt: nil,
		},
	}

	output, err := generateJSONOutput(secrets, true)
	if err != nil {
		t.Fatalf("generateJSONOutput with metadata failed: %v", err)
	}

	// Check metadata fields
	if !strings.Contains(output, `"value": "secret123"`) {
		t.Errorf("output should contain value field, got: %s", output)
	}
	if !strings.Contains(output, `"created_at":`) {
		t.Errorf("output should contain created_at field, got: %s", output)
	}
	if !strings.Contains(output, `"updated_at":`) {
		t.Errorf("output should contain updated_at field, got: %s", output)
	}
}

func TestGenerateJSONOutputWithExpiration(t *testing.T) {
	now := time.Now()
	expiry := now.Add(24 * time.Hour)
	secrets := []exportSecretData{
		{
			key:       "api/key",
			envName:   "API_KEY",
			value:     []byte("secret123"),
			createdAt: now,
			updatedAt: now,
			expiresAt: &expiry,
		},
	}

	output, err := generateJSONOutput(secrets, true)
	if err != nil {
		t.Fatalf("generateJSONOutput with expiration failed: %v", err)
	}

	if !strings.Contains(output, `"expires_at":`) {
		t.Errorf("output should contain expires_at field, got: %s", output)
	}
}

func TestWriteSecureFile(t *testing.T) {
	// Create temp directory
	tmpDir := t.TempDir()

	t.Run("write to simple path", func(t *testing.T) {
		path := filepath.Join(tmpDir, "test.env")
		content := "TEST=value"

		err := writeSecureFile(path, content)
		if err != nil {
			t.Fatalf("writeSecureFile failed: %v", err)
		}

		// Verify file exists
		info, err := os.Stat(path)
		if err != nil {
			t.Fatalf("failed to stat file: %v", err)
		}

		// Verify permissions (0600)
		if info.Mode().Perm() != 0600 {
			t.Errorf("file permissions = %o, want 0600", info.Mode().Perm())
		}

		// Verify content
		data, err := os.ReadFile(path)
		if err != nil {
			t.Fatalf("failed to read file: %v", err)
		}
		if string(data) != content {
			t.Errorf("file content = %q, want %q", string(data), content)
		}
	})

	t.Run("write to nested path", func(t *testing.T) {
		path := filepath.Join(tmpDir, "subdir", "nested", "test.json")
		content := `{"key": "value"}`

		err := writeSecureFile(path, content)
		if err != nil {
			t.Fatalf("writeSecureFile to nested path failed: %v", err)
		}

		// Verify file exists
		_, err = os.Stat(path)
		if err != nil {
			t.Fatalf("nested file not created: %v", err)
		}
	})

	t.Run("write to current directory", func(t *testing.T) {
		// Change to temp dir
		oldWd, _ := os.Getwd()
		defer func() { _ = os.Chdir(oldWd) }()
		_ = os.Chdir(tmpDir)

		path := "current.env"
		content := "CURRENT=true"

		err := writeSecureFile(path, content)
		if err != nil {
			t.Fatalf("writeSecureFile to current dir failed: %v", err)
		}

		// Verify file exists
		_, err = os.Stat(filepath.Join(tmpDir, path))
		if err != nil {
			t.Fatalf("file in current dir not created: %v", err)
		}
	})
}

func TestExportSecretDataStruct(t *testing.T) {
	now := time.Now()
	expiry := now.Add(time.Hour)

	data := exportSecretData{
		key:       "test/key",
		envName:   "TEST_KEY",
		value:     []byte("secret"),
		createdAt: now,
		updatedAt: now,
		expiresAt: &expiry,
	}

	if data.key != "test/key" {
		t.Errorf("key = %s, want test/key", data.key)
	}
	if data.envName != "TEST_KEY" {
		t.Errorf("envName = %s, want TEST_KEY", data.envName)
	}
	if string(data.value) != "secret" {
		t.Errorf("value = %s, want secret", string(data.value))
	}
	if data.expiresAt == nil {
		t.Error("expiresAt should not be nil")
	}
}

func TestExportSecretMetadataStruct(t *testing.T) {
	created := "2025-01-01T00:00:00Z"
	updated := "2025-01-02T00:00:00Z"

	meta := exportSecretMetadata{
		Value:     "secret",
		CreatedAt: &created,
		UpdatedAt: &updated,
		ExpiresAt: nil,
	}

	if meta.Value != "secret" {
		t.Errorf("Value = %s, want secret", meta.Value)
	}
	if *meta.CreatedAt != created {
		t.Errorf("CreatedAt = %s, want %s", *meta.CreatedAt, created)
	}
	if meta.ExpiresAt != nil {
		t.Error("ExpiresAt should be nil")
	}
}
