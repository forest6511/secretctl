// Package main provides the secretctl CLI commands.
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/spf13/cobra"
)

// Export format constants
const (
	formatEnv  = "env"
	formatJSON = "json"
)

// Export command flags
var (
	exportFormat       string
	exportOutput       string
	exportKeys         []string
	exportWithMetadata bool
)

func init() {
	rootCmd.AddCommand(exportCmd)

	exportCmd.Flags().StringVarP(&exportFormat, "format", "f", "env", "Output format: env, json")
	exportCmd.Flags().StringVarP(&exportOutput, "output", "o", "", "Output file path (default: stdout)")
	exportCmd.Flags().StringSliceVarP(&exportKeys, "key", "k", nil, "Keys to export (glob pattern supported)")
	exportCmd.Flags().BoolVar(&exportWithMetadata, "with-metadata", false, "Include metadata in JSON output")
}

var exportCmd = &cobra.Command{
	Use:   "export",
	Short: "Export secrets to .env or JSON format",
	Long: `Export secrets from the vault to .env or JSON format.

Examples:
  # Export all secrets to stdout in .env format
  secretctl export

  # Export specific secrets to a file
  secretctl export -k "aws/*" -o .env

  # Export as JSON
  secretctl export -f json -o secrets.json

  # Export with metadata (JSON only)
  secretctl export -f json --with-metadata`,
	RunE: executeExport,
}

// exportSecretData holds secret data for export
type exportSecretData struct {
	key       string
	envName   string
	value     []byte
	createdAt time.Time
	updatedAt time.Time
	expiresAt *time.Time
}

// exportSecretMetadata holds secret metadata for JSON export with metadata
type exportSecretMetadata struct {
	Value     string  `json:"value"`
	CreatedAt *string `json:"created_at,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
	ExpiresAt *string `json:"expires_at,omitempty"`
}

func executeExport(cmd *cobra.Command, args []string) error {
	// Validate format
	exportFormat = strings.ToLower(exportFormat)
	if exportFormat != formatEnv && exportFormat != formatJSON {
		return fmt.Errorf("invalid format '%s': must be '%s' or '%s'", exportFormat, formatEnv, formatJSON)
	}

	// with-metadata only works with JSON format
	if exportWithMetadata && exportFormat != formatJSON {
		return fmt.Errorf("--with-metadata flag is only valid with JSON format")
	}

	// Unlock vault
	if err := ensureUnlocked(); err != nil {
		return err
	}
	defer v.Lock()

	// Get all available keys
	allKeys, err := v.ListSecrets()
	if err != nil {
		return fmt.Errorf("failed to list secrets: %w", err)
	}

	if len(allKeys) == 0 {
		return fmt.Errorf("no secrets in vault")
	}

	// Determine which keys to export
	var keysToExport []string
	if len(exportKeys) == 0 {
		// Export all keys
		keysToExport = allKeys
	} else {
		// Expand patterns
		seen := make(map[string]bool)
		for _, pattern := range exportKeys {
			matches, err := expandPattern(pattern, allKeys)
			if err != nil {
				return err
			}
			for _, key := range matches {
				if !seen[key] {
					seen[key] = true
					keysToExport = append(keysToExport, key)
				}
			}
		}
	}

	// Sort keys for consistent output
	sort.Strings(keysToExport)

	// Collect secrets
	var secrets []exportSecretData
	for _, key := range keysToExport {
		entry, err := v.GetSecret(key)
		if err != nil {
			return fmt.Errorf("failed to get secret '%s': %w", key, err)
		}
		secrets = append(secrets, exportSecretData{
			key:       key,
			envName:   keyToEnvName(key),
			value:     entry.Value,
			createdAt: entry.CreatedAt,
			updatedAt: entry.UpdatedAt,
			expiresAt: entry.ExpiresAt,
		})
	}

	// Generate output
	var output string
	switch exportFormat {
	case formatEnv:
		output = generateEnvOutput(secrets)
	case formatJSON:
		var err error
		output, err = generateJSONOutput(secrets, exportWithMetadata)
		if err != nil {
			return err
		}
	}

	// Write output
	if exportOutput == "" {
		// Output to stdout
		fmt.Fprint(os.Stderr, "WARNING: DO NOT COMMIT THIS OUTPUT TO VERSION CONTROL\n")
		fmt.Print(output)
	} else {
		// Output to file
		if err := writeSecureFile(exportOutput, output); err != nil {
			return err
		}
		fmt.Fprintf(os.Stderr, "Exported %d secrets to %s\n", len(secrets), exportOutput)
	}

	// TODO: Add audit logging when audit logger is integrated into CLI commands
	// auditLogger.Log with OpSecretExport

	return nil
}

// generateEnvOutput generates .env format output
func generateEnvOutput(secrets []exportSecretData) string {
	var sb strings.Builder
	sb.WriteString("# Generated by secretctl\n")
	sb.WriteString("# WARNING: DO NOT COMMIT THIS FILE TO VERSION CONTROL\n")
	sb.WriteString("#\n")

	for _, s := range secrets {
		// Escape special characters in value for .env format
		value := escapeEnvValue(string(s.value))
		sb.WriteString(fmt.Sprintf("%s=%s\n", s.envName, value))
	}

	return sb.String()
}

// escapeEnvValue escapes a value for .env format
// Values with special characters are quoted
func escapeEnvValue(value string) string {
	// Check if value needs quoting
	needsQuote := false
	for _, c := range value {
		if c == ' ' || c == '"' || c == '\'' || c == '\\' || c == '\n' || c == '\r' || c == '\t' || c == '#' || c == '$' {
			needsQuote = true
			break
		}
	}

	if !needsQuote {
		return value
	}

	// Use double quotes and escape special characters
	escaped := strings.ReplaceAll(value, "\\", "\\\\")
	escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
	escaped = strings.ReplaceAll(escaped, "\n", "\\n")
	escaped = strings.ReplaceAll(escaped, "\r", "\\r")
	escaped = strings.ReplaceAll(escaped, "\t", "\\t")
	escaped = strings.ReplaceAll(escaped, "$", "\\$")

	return "\"" + escaped + "\""
}

// generateJSONOutput generates JSON format output
func generateJSONOutput(secrets []exportSecretData, withMetadata bool) (string, error) {
	if withMetadata {
		// JSON with metadata
		result := make(map[string]exportSecretMetadata)
		for _, s := range secrets {
			meta := exportSecretMetadata{
				Value: string(s.value),
			}
			// Format timestamps as RFC3339
			createdAt := s.createdAt.Format(time.RFC3339)
			meta.CreatedAt = &createdAt
			updatedAt := s.updatedAt.Format(time.RFC3339)
			meta.UpdatedAt = &updatedAt
			if s.expiresAt != nil {
				expiresAt := s.expiresAt.Format(time.RFC3339)
				meta.ExpiresAt = &expiresAt
			}
			result[s.envName] = meta
		}
		data, err := json.MarshalIndent(result, "", "  ")
		if err != nil {
			return "", fmt.Errorf("failed to marshal JSON: %w", err)
		}
		return string(data) + "\n", nil
	}

	// Simple key-value JSON
	result := make(map[string]string)
	for _, s := range secrets {
		result[s.envName] = string(s.value)
	}
	data, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal JSON: %w", err)
	}
	return string(data) + "\n", nil
}

// writeSecureFile writes content to a file with 0600 permissions
func writeSecureFile(path string, content string) error {
	// Ensure parent directory exists
	dir := filepath.Dir(path)
	if dir != "." && dir != "/" {
		if err := os.MkdirAll(dir, 0700); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
	}

	// Write file with secure permissions
	if err := os.WriteFile(path, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}
